#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "runtime.h"

// Main entry point that calls the Ballerina program
int main(int argc, char* argv[]) {
    // Call the ballerina_main function that was generated by the compiler
    ballerina_main();
    
    return 0;
}

// Print a string to stdout
void ballerina_print_string(const char* str) {
    if (str) {
        printf("%s", str);
    } else {
        printf("(null)");
    }
}

// Legacy simple println for debugging
void ballerina_io_println_simple(const char* str) {
    if (str) {
        printf("%s\n", str);
    } else {
        printf("(null)\n");
    }
}

// String functions

// Create a string with a literal (used for constant strings)
BallerinaString* ballerina_string_new_with_literal(const char* data, int64_t length) {
    // Allocate memory for the string structure (heap)
    BallerinaString* str = (BallerinaString*)malloc(sizeof(BallerinaString));
    if (!str) {
        fprintf(stderr, "Error: Failed to allocate memory for string\n");
        exit(1);
    }
    // Allocate memory for the string data and copy it (heap)
    char* dataPtr = (char*)malloc(length + 1);
    if (!dataPtr) {
        fprintf(stderr, "Error: Failed to allocate memory for string data\n");
        free(str);
        exit(1);
    }
    memcpy(dataPtr, data, length);
    dataPtr[length] = '\0';
    str->length = length;
    str->data = dataPtr;
    return str;
}

// Print a string (used by println)
void ballerina_io_println(BallerinaString* value) {
    if (!value) {
        printf("(null)\n");
        fflush(stdout);
        return;
    }
    BallerinaString* str = (BallerinaString*)value;
    if (!str->data) {
        printf("(empty)\n");
        fflush(stdout);
        return;
    }
    if (str->length < 0 || str->length > 10000) {
        str->length = strlen(str->data); // Try to recover
    }
    printf("%.*s\n", (int)str->length, str->data);
    fflush(stdout);
}

// Print an array (used by println with arrays)
void ballerina_io_println_array(BallerinaArray* array) {
    if (!array) {
        printf("(null array)\n");
        fflush(stdout);
        return;
    }
    if (array->length <= 0 || !array->data) {
        printf("(empty array)\n");
        fflush(stdout);
        return;
    }
    // Assume the array contains BallerinaString* elements
    // Extract the first element and print it
    BallerinaString** stringArray = (BallerinaString**)array->data;
    BallerinaString* firstString = stringArray[0];
    // Call the regular string println function
    ballerina_io_println(firstString);
}

// Create a new map
BallerinaMap* ballerina_lang_map_new() {
    BallerinaMap* map = (BallerinaMap*)malloc(sizeof(BallerinaMap));
    if (!map) {
        fprintf(stderr, "Failed to allocate memory for map\n");
        exit(1);
    }
    map->size = 0;
    map->capacity = 16; // Initial capacity
    map->data = NULL;   // No actual storage implemented yet
    return map;
}

// Create a new array with the given size and element size
BallerinaArray* ballerina_lang_array_new(int64_t size, int64_t elementSize) {
    BallerinaArray* arr = (BallerinaArray*)malloc(sizeof(BallerinaArray));
    if (!arr) {
        fprintf(stderr, "Failed to allocate memory for array\n");
        exit(1);
    }
    // Allocate memory for array elements
    void* data = NULL;
    if (size > 0) {
        data = calloc(size, elementSize);
        if (!data) {
            fprintf(stderr, "Failed to allocate memory for array data\n");
            free(arr);
            exit(1);
        }
    }
    arr->length = size;
    arr->data = data;
    return arr;
}

// Set an element in an array at the given index
void ballerina_lang_array_set(BallerinaArray* arr, int64_t index, void* value) {
    if (!arr || !arr->data || index < 0 || index >= arr->length) {
        fprintf(stderr, "Array set error: invalid array or index\n");
        return;
    }
    // For now, assume we're dealing with pointer-sized elements (BallerinaString*)
    // This could be improved to handle different element sizes properly
    void** elements = (void**)arr->data;
    elements[index] = value;
}

// Concatenate two strings
BallerinaString* ballerina_lang_string_concat(BallerinaString* str1, BallerinaString* str2) {
    if (!str1 || !str2) {
        return ballerina_string_new_with_literal("", 0);
    }

    int64_t newLen = str1->length + str2->length;
    BallerinaString* result = (BallerinaString*)malloc(sizeof(BallerinaString));
    if (!result) {
        fprintf(stderr, "Failed to allocate memory for concatenated string\n");
        exit(1);
    }
    char* newData = (char*)malloc(newLen + 1);
    if (!newData) {
        fprintf(stderr, "Failed to allocate memory for concatenated string data\n");
        free(result);
        exit(1);
    }
    memcpy(newData, str1->data, str1->length);
    memcpy(newData + str1->length, str2->data, str2->length);
    newData[newLen] = '\0';
    result->length = newLen;
    result->data = newData;
    return result;
}

// Convert an integer to a Ballerina string
BallerinaString* ballerina_runtime_int_to_string(int64_t val) {
    // Always returns a heap-allocated BallerinaString* object
    char buffer[22];
    int len = snprintf(buffer, sizeof(buffer), "%lld", (long long)val);
    if (len < 0) {
        return ballerina_string_new_with_literal("", 0);
    }
    return ballerina_string_new_with_literal(buffer, (int64_t)len);
}

// Convert a boolean to a Ballerina string
BallerinaString* ballerina_runtime_bool_to_string(int8_t val) {
    if (val) {
        return ballerina_string_new_with_literal("true", 4);
    } else {
        return ballerina_string_new_with_literal("false", 5);
    }
}

// Create a Ballerina error from a message string
void* ballerina_error_create(BallerinaString* message) {
    // Print the error message immediately
    printf("error: ");
    if (message) {
        printf("%.*s\n", (int)message->length, message->data);
    } else {
        printf("(unknown error)\n");
    }
    
    // Return the message pointer as the error object
    // In a real implementation, we would create a proper error object
    return message;
}

// Print a Ballerina error
void ballerina_error_print(void* error) {
    BallerinaString* errorMsg = (BallerinaString*)error;
    printf("error: ");
    if (errorMsg && errorMsg->data) {
        printf("%.*s\n", (int)errorMsg->length, errorMsg->data);
    } else {
        printf("(unknown error)\n");
    }
}

// Print a float value
void ballerina_io_println_float(double value) {
    printf("%.1f\n", value);
}

// Print a boolean value
void ballerina_io_println_bool(int value) {
    printf("%s\n", value ? "true" : "false");
}

// Print an integer value  
void ballerina_io_println_int(long long value) {
    printf("%lld\n", value);
}