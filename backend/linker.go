package backend

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
)

// LinkObjectFile links the generated object file into an executable
func LinkObjectFile(objectFile, executableFile string) error {
	cc := "cc" // Default C compiler command

	// Get the absolute path to the runtime object files
	runtimeDir := getRuntimeDir()
	runtimeObjPath := filepath.Join(runtimeDir, "runtime.o")
	httpServerObjPath := filepath.Join(runtimeDir, "http_server.o")
	goHttpLibPath := filepath.Join(runtimeDir, "http_server_go.a")

	// Check if runtime.o exists
	if _, err := os.Stat(runtimeObjPath); os.IsNotExist(err) {
		return fmt.Errorf("runtime.o not found at %s - run 'make runtime' to build it", runtimeObjPath)
	}

	// Check if http_server.o exists
	if _, err := os.Stat(httpServerObjPath); os.IsNotExist(err) {
		return fmt.Errorf("http_server.o not found at %s - run 'make' in runtime directory to build it", httpServerObjPath)
	}

	// Check if Go HTTP library exists
	if _, err := os.Stat(goHttpLibPath); os.IsNotExist(err) {
		return fmt.Errorf("http_server_go.a not found at %s - run 'make' in runtime directory to build it", goHttpLibPath)
	}

	// First, verify that the object file contains ballerina_main
	hasSymbol := false
	if runtime.GOOS == "darwin" {
		nmCmd := exec.Command("nm", "-g", objectFile)
		nmOutput, err := nmCmd.CombinedOutput()
		if err != nil {
			fmt.Printf("Warning: Unable to check symbols: %v\n", err)
		} else {
			nmOutputStr := string(nmOutput)
			fmt.Printf("Object file symbols:\n%s\n", nmOutputStr)

			// Check for both unmangled and mangled symbol names
			if strings.Contains(nmOutputStr, "ballerina_main") ||
				strings.Contains(nmOutputStr, "_ballerina_main") {
				fmt.Println("Found ballerina_main symbol in object file")
				hasSymbol = true
			} else {
				fmt.Println("WARNING: ballerina_main symbol not found in object file!")
			}
		}
	}
	if hasSymbol {
	}

	// Create a simplified wrapper.c that doesn't require a separate object file
	wrapperPath := filepath.Join(os.TempDir(), "wrapper.c")
	wrapperContent := `
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

// Ballerina main function declaration (generated by compiler)
extern void ballerina_main(void);

// Signal handler for debugging
void signal_handler(int signal) {
    fprintf(stderr, "Caught signal %d (segmentation fault)\n", signal);
    exit(1);
}

// Use a different name for the main function in the wrapper
// Will become the real entry point (C's main)
int wrapper_main(int argc, char** argv) {
    // Set up signal handler for debugging
    signal(SIGSEGV, signal_handler);
    
    printf("Starting Ballerina program...\n");
    
    // Call Ballerina main with error handling
    ballerina_main();
    
    printf("Ballerina program completed successfully.\n");
    return 0;
}

// Define a weak alias for wrapper_main to be the C entry point
// This ensures it's only used if there's no other 'main' defined
#ifdef __APPLE__
__attribute__((weak, visibility("default")))
#else
__attribute__((weak))
#endif
int main(int argc, char** argv) {
    return wrapper_main(argc, argv);
}
`
	if err := os.WriteFile(wrapperPath, []byte(wrapperContent), 0644); err != nil {
		return fmt.Errorf("failed to create wrapper file: %v", err)
	}
	defer os.Remove(wrapperPath)

	// Determine platform-specific linker flags
	ldflags := []string{}

	switch runtime.GOOS {
	case "darwin":
		// For macOS
		ldflags = append(ldflags, "-fPIC")

		// Don't force symbol export with flags, it causes problems on some macOS versions

		// Force the linker to search in the current directory first for libraries
		ldflags = append(ldflags, "-Wl,-search_paths_first")

		// Since we're generating ARM64 code, explicitly set the architecture
		if runtime.GOARCH == "arm64" {
			ldflags = append(ldflags, "-arch", "arm64")
		}

		// Add required macOS frameworks for Go CGO
		ldflags = append(ldflags, "-framework", "CoreFoundation")
		ldflags = append(ldflags, "-framework", "Security")
	case "linux":
		ldflags = append(ldflags, "-fPIC")
	case "windows":
		ldflags = append(ldflags, "-Wl,--export-all-symbols")
	}

	// Build command to compile the wrapper and link everything together
	ldflags = append(ldflags, "-o", executableFile)
	ldflags = append(ldflags, wrapperPath) // wrapper.c (not object)
	ldflags = append(ldflags, objectFile, runtimeObjPath, httpServerObjPath, goHttpLibPath)

	// Add debugging symbols
	ldflags = append(ldflags, "-g")

	// Build and execute the command
	fmt.Printf("Running linker command: %s %s\n", cc, strings.Join(ldflags, " "))
	linkCmd := exec.Command(cc, ldflags...)
	output, err := linkCmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("linking failed: %v\nCommand: %s %s\nOutput: %s",
			err, cc, strings.Join(ldflags, " "), string(output))
	}

	// Make the file executable
	if runtime.GOOS != "windows" {
		if err := os.Chmod(executableFile, 0755); err != nil {
			return fmt.Errorf("failed to make executable: %v", err)
		}
	}

	return nil
}

// getRuntimeDir returns the path to the runtime directory
func getRuntimeDir() string {
	// Attempt to locate runtime directory relative to the current executable
	executable, err := os.Executable()
	if err == nil {
		// Try standard locations relative to the executable
		execDir := filepath.Dir(executable)

		candidates := []string{
			filepath.Join(execDir, "runtime"),                // Same dir as executable
			filepath.Join(execDir, "..", "runtime"),          // One level up
			filepath.Join(execDir, "..", "share", "runtime"), // In share subdirectory
		}

		for _, path := range candidates {
			if _, err := os.Stat(path); err == nil {
				return path
			}
		}
	}

	// Fallback to relative path from current directory
	return filepath.Join(".", "runtime")
}
