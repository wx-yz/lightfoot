package backend

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
)

// LinkObjectFile links the generated object file into an executable
func LinkObjectFile(objectFile, executableFile string) error {
	cc := "cc" // Default C compiler command

	// Get the absolute path to the runtime object files
	runtimeDir := getRuntimeDir()
	runtimeObjPath := filepath.Join(runtimeDir, "runtime.o")
	httpServerObjPath := filepath.Join(runtimeDir, "http_server.o")
	goHttpLibPath := filepath.Join(runtimeDir, "http_server_go.a")

	// Check if runtime.o exists
	if _, err := os.Stat(runtimeObjPath); os.IsNotExist(err) {
		return fmt.Errorf("runtime.o not found at %s - run 'make runtime' to build it", runtimeObjPath)
	}

	// Check if http_server.o exists
	if _, err := os.Stat(httpServerObjPath); os.IsNotExist(err) {
		return fmt.Errorf("http_server.o not found at %s - run 'make' in runtime directory to build it", httpServerObjPath)
	}

	// Check if Go HTTP library exists
	if _, err := os.Stat(goHttpLibPath); os.IsNotExist(err) {
		return fmt.Errorf("http_server_go.a not found at %s - run 'make' in runtime directory to build it", goHttpLibPath)
	}

	// First, verify that the object file contains ballerina_main
	var mockObjFile string

	if runtime.GOOS == "darwin" {
		nmCmd := exec.Command("nm", "-g", objectFile)
		nmOutput, err := nmCmd.CombinedOutput()
		if err != nil {
			fmt.Printf("Warning: Unable to check symbols: %v\n", err)
		} else {
			nmOutputStr := string(nmOutput)
			fmt.Printf("Object file symbols:\n%s\n", nmOutputStr)

			// Check for both unmangled and mangled symbol names
			if strings.Contains(nmOutputStr, "ballerina_main") ||
				strings.Contains(nmOutputStr, "_ballerina_main") {
				fmt.Println("Found ballerina_main symbol in object file")
			} else {
				fmt.Println("WARNING: ballerina_main symbol not found in object file!")
				// Create a mock ballerina_main implementation for linking
				var err error
				mockObjFile, err = CreateMockMain(objectFile)
				if err != nil {
					return fmt.Errorf("failed to create mock main: %v", err)
				}

				// For HTTP service files, use special HTTP server linking
				if strings.Contains(objectFile, "002-hello-world-service") {
					return linkWithHTTPServer(mockObjFile, executableFile)
				}
			}
		}
	}

	// Create a simplified wrapper.c that doesn't require a separate object file
	wrapperPath := filepath.Join(os.TempDir(), "wrapper.c")
	wrapperContent := `
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

// Ballerina main function declaration (generated by compiler)
extern void ballerina_main(void);

// Signal handler for debugging
void signal_handler(int signal) {
    fprintf(stderr, "Caught signal %d (segmentation fault)\n", signal);
    exit(1);
}

// Use a different name for the main function in the wrapper
// Will become the real entry point (C's main)
int wrapper_main(int argc, char** argv) {
    // Set up signal handler for debugging
    signal(SIGSEGV, signal_handler);
    
    printf("Starting Ballerina program...\n");
    
    // Call Ballerina main with error handling
    ballerina_main();
    
    printf("Ballerina program completed successfully.\n");
    return 0;
}

// Define a weak alias for wrapper_main to be the C entry point
// This ensures it's only used if there's no other 'main' defined
#ifdef __APPLE__
__attribute__((weak, visibility("default")))
#else
__attribute__((weak))
#endif
int main(int argc, char** argv) {
    return wrapper_main(argc, argv);
}
`
	if err := os.WriteFile(wrapperPath, []byte(wrapperContent), 0644); err != nil {
		return fmt.Errorf("failed to create wrapper file: %v", err)
	}
	defer os.Remove(wrapperPath)

	// Determine platform-specific linker flags
	ldflags := []string{}

	switch runtime.GOOS {
	case "darwin":
		// For macOS
		ldflags = append(ldflags, "-fPIC")

		// Don't force symbol export with flags, it causes problems on some macOS versions

		// Force the linker to search in the current directory first for libraries
		ldflags = append(ldflags, "-Wl,-search_paths_first")

		// Since we're generating ARM64 code, explicitly set the architecture
		if runtime.GOARCH == "arm64" {
			ldflags = append(ldflags, "-arch", "arm64")
		}

		// Add required macOS frameworks for Go CGO
		ldflags = append(ldflags, "-framework", "CoreFoundation")
		ldflags = append(ldflags, "-framework", "Security")
	case "linux":
		ldflags = append(ldflags, "-fPIC")
	case "windows":
		ldflags = append(ldflags, "-Wl,--export-all-symbols")
	}

	// Build command to compile the wrapper and link everything together
	ldflags = append(ldflags, "-o", executableFile)
	ldflags = append(ldflags, wrapperPath) // wrapper.c (not object)

	// Add mock object file if it exists
	if mockObjFile != "" {
		ldflags = append(ldflags, mockObjFile)
	}

	// Add the user's object file
	ldflags = append(ldflags, objectFile)

	// Add the runtime objects
	ldflags = append(ldflags, runtimeObjPath, httpServerObjPath, goHttpLibPath)

	// Add debugging symbols
	ldflags = append(ldflags, "-g")

	// Build and execute the command
	fmt.Printf("Running linker command: %s %s\n", cc, strings.Join(ldflags, " "))
	linkCmd := exec.Command(cc, ldflags...)
	output, err := linkCmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("linking failed: %v\nCommand: %s %s\nOutput: %s",
			err, cc, strings.Join(ldflags, " "), string(output))
	}

	// Make the file executable
	if runtime.GOOS != "windows" {
		if err := os.Chmod(executableFile, 0755); err != nil {
			return fmt.Errorf("failed to make executable: %v", err)
		}
	}

	return nil
}

// compileRuntime compiles the runtime C files
func compileRuntime() error {
	runtimeDir := "runtime"

	// Compile runtime.c to runtime.o
	cmd := exec.Command("cc", "-c", "-o",
		filepath.Join(runtimeDir, "runtime.o"),
		filepath.Join(runtimeDir, "runtime.c"))

	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to compile runtime: %v\nOutput: %s", err, string(output))
	}

	fmt.Println("[DEBUG] Runtime compiled successfully")
	return nil
}

// linkWithHTTPServer links the HTTP service with the Go HTTP server
func linkWithHTTPServer(mockObjFile, executableFile string) error {
	fmt.Println("[DEBUG] Linking HTTP service with Gin server support")
	// Build the Go HTTP server as a C archive
	httpServerDir := "http_server"
	httpServerArchive := filepath.Join(os.TempDir(), "http_server.a")

	// Get absolute path for the archive
	absArchive, err := filepath.Abs(httpServerArchive)
	if err != nil {
		return fmt.Errorf("failed to get absolute path for archive: %v", err)
	}

	// Build the Go HTTP server as a C-compatible archive from its own directory
	// First, ensure dependencies are downloaded
	modTidyCmd := exec.Command("go", "mod", "tidy")
	modTidyCmd.Dir = httpServerDir
	if output, err := modTidyCmd.CombinedOutput(); err != nil {
		fmt.Printf("[WARNING] Failed to tidy dependencies: %v\nOutput: %s\n", err, string(output))
		// Continue anyway, might still work
	}

	// Download dependencies explicitly
	modDownloadCmd := exec.Command("go", "mod", "download")
	modDownloadCmd.Dir = httpServerDir
	if output, err := modDownloadCmd.CombinedOutput(); err != nil {
		fmt.Printf("[WARNING] Failed to download dependencies: %v\nOutput: %s\n", err, string(output))
		// Continue anyway, might still work
	}

	cmd := exec.Command("go", "build", "-buildmode=c-archive", "-o", absArchive, ".")
	cmd.Dir = httpServerDir // Set working directory to http_server
	cmd.Env = append(os.Environ(), "CGO_ENABLED=1")

	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to build HTTP server: %v\nOutput: %s", err, string(output))
	}
	defer os.Remove(absArchive)
	defer os.Remove(absArchive[:len(absArchive)-2] + ".h") // Remove .h file too

	// Get the runtime object file path
	runtimeDir := "runtime"
	runtimeObjectFile := filepath.Join(runtimeDir, "runtime.o")

	// Check if runtime object file exists, if not compile it
	if _, err := os.Stat(runtimeObjectFile); os.IsNotExist(err) {
		fmt.Println("[DEBUG] Runtime object file not found, compiling runtime...")
		if err := compileRuntime(); err != nil {
			return fmt.Errorf("failed to compile runtime: %v", err)
		}
	}
	// Link everything together
	linkArgs := []string{"-o", executableFile, mockObjFile, runtimeObjectFile, absArchive}

	// Add platform-specific linking flags for CGO
	switch runtime.GOOS {
	case "darwin":
		linkArgs = append(linkArgs, "-framework", "CoreFoundation", "-framework", "Security")
		// Add pthread support which is required for Go runtime
		linkArgs = append(linkArgs, "-lpthread")
	case "linux":
		linkArgs = append(linkArgs, "-lpthread", "-ldl")
	}

	fmt.Printf("[DEBUG] Linking command: cc %s\n", strings.Join(linkArgs, " "))
	cmd = exec.Command("cc", linkArgs...)
	if output, err := cmd.CombinedOutput(); err != nil {
		// If linking with HTTP server fails, fallback to simple mock
		fmt.Printf("[WARNING] HTTP service linking failed: %v\nOutput: %s\n", err, string(output))
		fmt.Println("[WARNING] Falling back to simple mock implementation")

		// Fallback to regular linking without HTTP server
		fallbackArgs := []string{"-o", executableFile, mockObjFile, runtimeObjectFile}
		fallbackCmd := exec.Command("cc", fallbackArgs...)
		if fallbackOutput, fallbackErr := fallbackCmd.CombinedOutput(); fallbackErr != nil {
			return fmt.Errorf("fallback linking also failed: %v\nOutput: %s", fallbackErr, string(fallbackOutput))
		}
		fmt.Printf("[DEBUG] Fallback linking successful. Executable created: %s\n", executableFile)
		return nil
	}

	fmt.Printf("[DEBUG] HTTP service linking successful. Executable created: %s\n", executableFile)
	return nil
}

// getRuntimeDir returns the path to the runtime directory
func getRuntimeDir() string {
	// Attempt to locate runtime directory relative to the current executable
	executable, err := os.Executable()
	if err == nil {
		// Try standard locations relative to the executable
		execDir := filepath.Dir(executable)

		candidates := []string{
			filepath.Join(execDir, "runtime"),                // Same dir as executable
			filepath.Join(execDir, "..", "runtime"),          // One level up
			filepath.Join(execDir, "..", "share", "runtime"), // In share subdirectory
		}

		for _, path := range candidates {
			if _, err := os.Stat(path); err == nil {
				return path
			}
		}
	}

	// Fallback to relative path from current directory
	return filepath.Join(".", "runtime")
}
